#include "stdafx.h"
#include <iostream>
#include <ctime>
#include <blocked_range.h>
#include <parallel_reduce.h>

using namespace std;
using namespace tbb;

class F // Плохое имя для класса. Имя должно говорить, ЧТО класс делает.
{
public:

    int sum; // Не надо делать поля публичными. Правильно будет sum засунуть в private
    // и добавить int result() { return sum; }
    //
    // А оно точно int? Суммируются же вещественные числа?

    F(int N)
    {
        this-> N = N; //мне кажеься что в этом случае N должен быть в public
        // Нет, не должен, но лучше использвать правильный синтаксис:
        // F(int n) : N(n), sum(0) { }
        sum = 0;
    }

    F(F f, split) // <--- ОШИБКА: какого типа split?
    {
        N = f.N; // а что это вообще такое?? split то я знаю, но на паре и сейчас не могу понять че тут происходит
        // это то же самое, что выше с this, и писать это надо так же:
        // F(F f, int split) : N(f.N), sum(0) { }
        sum = 0;
    }

    void operator ()(blocked_range<int>& r) // тут не надо ли const blocked_range& ?
    {
        int n = 0;
        for (int i = r.begin(); i != r.end(); ++i)
        {
            double x = 1. * rand() / RAND_MAX * 4. - 2.;
            double y = 1. * rand() / RAND_MAX * 3. - 1.;
            // Ой. Это выражение меня пугает. Может его все-таки в функцию? И на части разбить?
            // А то вообще непонятно, что делается. Тут вероятность ошибки 90%.
            if ((x <= 0 && y >= (-1.5)* x - 1 && y <= -x) || (x >= 0 & y >= (1.5)*x - 1 && y <= x))
            {
                n++; // ++n же
            }
        }

        sum += 12. *n / N; //повторюсь что N соскучилась по паблику
        // нет, не нужен тут public, это же изнутри класса обращение. А вот sum точно не int!!!
    }

    void join(F&g) //а почему именно такой синтаксис? то есть именно оператором по адресу...
    // не к оператору, а к объекту класса по ссылке на него
    {
        sum += g.sum;
    }

private:

    int N; // а лучше const int N

};


int main()
{
    int N = 5000, n = 0; // Recipe for a disaster. НИКОГДА не пиши две инициализации в одной строке.
    srand(time(NULL));

    for (int i = 0; i <= N; ++i)
    {
        double x = 1. * rand() / RAND_MAX * 4. - 2.;
        double y = 1. * rand() / RAND_MAX * 3. - 1.;
        // вот если в этом выражении ошибка, то она в три места в программе растиражируется.
        // Тут ОЧЕНЬ надо функцию.
        if ((x <= 0 && y >= (-1.5)* x - 1 && y <= -x) || (x >= 0 & y >= (1.5)*x - 1 && y <= x))
        {
            n++;
        }
    }

    double s = 12 * n / N; //представь только - у нас тут было просто "s", без doublе. Я только сейчас заметила ошибку и написала double...кошмар. Но я думаю что проблема и в N.
    cout « s « endl;


    int nn = parallel_reduce(
        blocked_range<int>(0, N),
        0,

        [=](blocked_range<int>&r, int n)
        {
            for (int i = 0; i <= N; ++i)
            {
                // Не надо copy-paste, надо функцию. Тут даже забытый пробел трижды растиражирован.
                // Если тут есть ошибка, то будет очень трудно ее исправлять.
                double x = 1. * rand() / RAND_MAX * 4. - 2.;
                double y = 1. * rand() / RAND_MAX * 3. - 1.;
                if ((x <= 0 && y >= (-1.5)* x - 1 && y <= -x) || (x >= 0 & y >= (1.5)*x - 1 && y <= x))
                {
                    n++;
                }
            }

            return n;
        },

        [](int x, int y)
        {
            return x + y; //этл мы возвращаем сумму для того чтобы объединить посчитаные отрезки - но я не понимаю как это происходит :)
            // Это мы считаем, какого размера получилась область, если она была разбита на части. Тут неверно называть это x и y,
            // потому что не координаты это, а это N1 и N2. Если бы так назвать, было бы понятно все.
        }

    ); //кошмар закончился.

    double s = 12 * nn / N; //double
    cout « nn « endl;
    cout « s « endl;

    F h(N);
    parallel_reduce(blocked_range<int>(0, N), h);
    cout « h.sum « endl; //sum -это без лямбда функции и без заморочек - посчитанная площадь, да? в таком коде легко запутаться.

    return 0;
}

